## Java内存区域
![image](E:\MarkDown\image\java-memory-area.png)

1. 程序计数器  
    程序计数器是Java内存的很小一部分，用来记录当前线程执行程序的行号。每个程序计数器只能记录一个线程的行号，所以程序计数器是私有的。  
    
    如果运行Java程序，程序计数器记录正在执行的虚拟机字节码指令地址；如果运行本地方法，则计数器值为Undefined。程序计数器也是所有JVM内存区 域中唯一一个没有定义OutOfMemoryError的区域。  

2. 虚拟机栈  
    一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。  
    
    如果虚拟机栈内存不足，会抛出OutOfMemoryError(内存溢出)。每个线程对应一个虚拟机栈，所以虚拟机栈是私有的。  

3. 本地方法栈  
    本地方法栈和虚拟机栈相似，不同的是虚拟机栈运行Java方法，本地方法栈运行本地方法。  

4. 堆区  
    堆区是理解Java GC机制最重要的区域，堆区也是Java对象最重要的存储区域。堆区是线程共享的。  


5. 方法区  
    方法区用来存储已经加载的类信息（包括字段、方法、接口等信息）、常量、静态变量等等；在方法区上定义了OutOfMemoryError PermGen space异常，在内存不足时抛出。方法区线程共享区域。




## Java访问对象方式  
创建一个对象，例如  
    
```
Object o = new Object;
```
    
会涉及到3个Java内存区域：虚拟机栈、堆区和方法区。虚拟机栈存储对象引用o，堆区存储对象Object，方法区存储Object类型信息。  

目前主流的实现方式主要有两种：  
1. 通过句柄来访问  
![image](http://images.cnitblog.com/blog/406312/201309/21174354-8e55a4e6b6284153b8ac40cfeab3062d.png) 
通过在堆区开辟一块内存作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址），优势很稳定。  

2. 通过指针来访问  
![image](http://images.cnitblog.com/blog/406312/201309/21174413-e7b4a7cdec984c2881a56ad776d54354.png)  
通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。  
  

## Java内存分配机制  
这里所说的内存分配，主要指的是在堆上的分配; Java内存分配概括来说是分代分配。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）  

  
  ![image](http://images.cnitblog.com/blog/406312/201309/22011837-d7fa2942d1c041b8be184f503e63fa46.png)

#### 年轻代

年轻代（Young Generation）：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。  

年轻代可以分为3个区域：Eden区和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为:  

![image](http://images.cnitblog.com/blog/406312/201309/22014107-8698ab6bdb0f44389c0212ad2c1bae21.png)

1. 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；  

2. Survivor（一对）是存放MinorGC后存活的对象，只有一块持有对象，另外一块是空的。

3. 如上图演示MinorGC操作，灰色X标记代表需要被收集的对象；MinorGC后Eden和Survivor中的存活对象被复制到未使用的Survivor。如果占用Survivor里“足够老”的存活对象被提升到老年代（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）。

4. MinorGC后，如果Survivor可能不足以容纳Eden和另外一个Survivor中存活的对象，多余的对象会被移到老年代。

#### 老年代  
对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。

## JavaGC机制  
GC机制的基本算法是：分代收集。  
1. 新生代使用**停止-复制**算法
2. 老年代使用**标记-清除**算法
3. 永久代 ？？

## Java垃圾回收机制  
在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图：
![image](http://images.cnitblog.com/blog/406312/201309/23225652-8fe6831475f9437b91ff1e9d4fa9fabb.jpg)  

- Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。
- ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。
- Parallel Scavenge 收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。
- Serial Old收集器：老年代收集器，单线程收集器，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存 的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停.
- Parallel Old收集器：老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清 理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。
- CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。